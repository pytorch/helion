This file is automatically generated by assertExpectedJournal calls in test_closures.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestClosures.test_add_global)
from __future__ import annotations

import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

import helion._testing.basic_kernels as _source_module

@triton.jit
def _helion_use_globals(a, _source_module_attr_global_tensor, out, a_size_0, a_size_1, _source_module_attr_global_tensor_stride_0, a_stride_0, a_stride_1, out_stride_0, out_stride_1, _source_module_attr_global_float, _BLOCK_SIZE_0: tl.constexpr, _BLOCK_SIZE_1: tl.constexpr):
    num_blocks_0 = tl.cdiv(a_size_0, _BLOCK_SIZE_0)
    pid_0 = tl.program_id(0) % num_blocks_0
    pid_1 = tl.program_id(0) // num_blocks_0
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    offset_1 = pid_1 * _BLOCK_SIZE_1
    indices_1 = (offset_1 + tl.arange(0, _BLOCK_SIZE_1)).to(tl.int32)
    mask_1 = indices_1 < a_size_1
    load = tl.load(a + (indices_0[:, None] * a_stride_0 + indices_1[None, :] * a_stride_1), mask_0[:, None] & mask_1[None, :], other=0)
    load_1 = tl.load(_source_module_attr_global_tensor + indices_1[None, :] * _source_module_attr_global_tensor_stride_0, mask_1[None, :], other=0)
    v_0 = load + load_1
    v_1 = tl_math.sin(v_0)
    v_2 = v_1 + _source_module_attr_global_float
    tl.store(out + (indices_0[:, None] * out_stride_0 + indices_1[None, :] * out_stride_1), v_2, mask_0[:, None] & mask_1[None, :])

def use_globals(a, *, _launcher=_default_launcher):
    out = _source_module.empty_like(a)
    _BLOCK_SIZE_0 = 32
    _BLOCK_SIZE_1 = 32
    _launcher(_helion_use_globals, (triton.cdiv(a.size(0), _BLOCK_SIZE_0) * triton.cdiv(a.size(1), _BLOCK_SIZE_1),), a, _source_module.global_tensor, out, a.size(0), a.size(1), _source_module.global_tensor.stride(0), a.stride(0), a.stride(1), out.stride(0), out.stride(1), _source_module.global_float, _BLOCK_SIZE_0, _BLOCK_SIZE_1, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestClosures.test_fn_arg_with_closure)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_sin_func_arg(a, fn_closure_0, out, a_size_0, a_stride_0, fn_closure_0_stride_0, out_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    load = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    v_0 = tl_math.sin(load)
    load_1 = tl.load(fn_closure_0 + indices_0 * fn_closure_0_stride_0, mask_0, other=0)
    v_1 = v_0 + load_1
    tl.store(out + indices_0 * out_stride_0, v_1, mask_0)

def sin_func_arg(a, fn, *, _launcher=_default_launcher):
    out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 512
    _launcher(_helion_sin_func_arg, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, fn.__closure__[0].cell_contents, out, a.size(0), a.stride(0), fn.__closure__[0].cell_contents.stride(0), out.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestClosures.test_fn_arg_with_global)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

import test.test_closures as _source_module

@triton.jit
def _helion_sin_func_arg(a, _source_module_attr_global_tensor, out, a_size_0, _source_module_attr_global_tensor_stride_0, a_stride_0, out_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    load = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    v_0 = tl_math.sin(load)
    load_1 = tl.load(_source_module_attr_global_tensor + indices_0 * _source_module_attr_global_tensor_stride_0, mask_0, other=0)
    v_1 = v_0 + load_1
    tl.store(out + indices_0 * out_stride_0, v_1, mask_0)

def sin_func_arg(a, fn, *, _launcher=_default_launcher):
    out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 512
    _launcher(_helion_sin_func_arg, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, _source_module.global_tensor, out, a.size(0), _source_module.global_tensor.stride(0), a.stride(0), out.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestClosures.test_fn_arg_with_global_different_file)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

import helion._testing.basic_kernels as _global_source0

@triton.jit
def _helion_sin_func_arg(a, out, a_size_0, a_stride_0, out_stride_0, _global_source0_attr_global_float, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    load = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    v_0 = tl_math.sin(load)
    v_1 = v_0 + _global_source0_attr_global_float
    tl.store(out + indices_0 * out_stride_0, v_1, mask_0)

def sin_func_arg(a, fn, *, _launcher=_default_launcher):
    out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 512
    _launcher(_helion_sin_func_arg, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, out, a.size(0), a.stride(0), out.stride(0), _global_source0.global_float, _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestClosures.test_fn_arg_with_nested_closure)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_sin_func_arg(a, fn_closure_0_closure_0, out, a_size_0, a_stride_0, fn_closure_0_closure_0_stride_0, out_stride_0, fn_closure_1, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    load = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    v_0 = tl_math.sin(load)
    load_1 = tl.load(fn_closure_0_closure_0 + indices_0 * fn_closure_0_closure_0_stride_0, mask_0, other=0)
    v_1 = v_0 + load_1
    v_2 = fn_closure_1.to(tl.float32)
    v_3 = v_1 + v_2
    tl.store(out + indices_0 * out_stride_0, v_3, mask_0)

def sin_func_arg(a, fn, *, _launcher=_default_launcher):
    out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 512
    _launcher(_helion_sin_func_arg, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, fn.__closure__[0].cell_contents.__closure__[0].cell_contents, out, a.size(0), a.stride(0), fn.__closure__[0].cell_contents.__closure__[0].cell_contents.stride(0), out.stride(0), fn.__closure__[1].cell_contents, _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestClosures.test_fn_called_on_host)
from __future__ import annotations

import triton
import triton.language as tl
from torch._inductor.runtime.triton_helpers import math as tl_math
from helion.runtime import default_launcher as _default_launcher

import test.test_closures as _source_module

@triton.jit
def _helion_call_func_arg_on_host(a, out, a_size_0, a_stride_0, out_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    load = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    v_0 = tl_math.sin(load)
    tl.store(out + indices_0 * out_stride_0, v_0, mask_0)

def call_func_arg_on_host(a, alloc, *, _launcher=_default_launcher):
    out = alloc(a)
    _BLOCK_SIZE_0 = 512
    _launcher(_helion_call_func_arg_on_host, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, out, a.size(0), a.stride(0), out.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out
