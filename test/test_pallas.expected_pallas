This file is automatically generated by assertExpectedJournal calls in test_pallas.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestPallas.test_add_1d)
from __future__ import annotations

import torch
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_add_kernel(x, y, out):
    # src[test_pallas.py:N]: out[tile] = x[tile] + y[tile]
    load = x[...]
    load_1 = y[...]
    v_0 = load + load_1
    out[...] = v_0

def add_kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: x, y = torch.broadcast_tensors(x, y)
    x, y = torch.broadcast_tensors(x, y)
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = x[tile] + y[tile]
    _launcher(_helion_add_kernel, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, y, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_add_large)
from __future__ import annotations

import torch
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_add_kernel(x, y, out):
    # src[test_pallas.py:N]: out[tile] = x[tile] + y[tile]
    load = x[...]
    load_1 = y[...]
    v_0 = load + load_1
    out[...] = v_0

def add_kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: x, y = torch.broadcast_tensors(x, y)
    x, y = torch.broadcast_tensors(x, y)
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 512
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = x[tile] + y[tile]
    _launcher(_helion_add_kernel, ((4096 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, y, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_pointwise_chain)
from __future__ import annotations

import torch
import jax
import jax.numpy as jnp
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_pointwise_chain(x, y, out):
    # src[test_pallas.py:N]: out[tile] = torch.sigmoid(torch.sin(torch.relu(x[tile] * y[tile])))
    load = x[...]
    load_1 = y[...]
    v_0 = load * load_1
    v_1 = jnp.maximum(v_0, 0)
    v_2 = jnp.sin(v_1)
    v_3 = jax.nn.sigmoid(v_2)
    out[...] = v_3

def pallas_pointwise_chain(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = torch.sigmoid(torch.sin(torch.relu(x[tile] * y[tile])))
    _launcher(_helion_pallas_pointwise_chain, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, y, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_pointwise_mul)
from __future__ import annotations

import torch
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_mul(x, y, out):
    # src[test_pallas.py:N]: out[tile] = x[tile] * y[tile]
    load = x[...]
    load_1 = y[...]
    v_0 = load * load_1
    out[...] = v_0

def pallas_mul(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = x[tile] * y[tile]
    _launcher(_helion_pallas_mul, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, y, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_pointwise_relu)
from __future__ import annotations

import torch
import jax.numpy as jnp
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_relu(x, out):
    # src[test_pallas.py:N]: out[tile] = torch.relu(x[tile])
    load = x[...]
    v_0 = jnp.maximum(load, 0)
    out[...] = v_0

def pallas_relu(x: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = torch.relu(x[tile])
    _launcher(_helion_pallas_relu, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_pointwise_sigmoid)
from __future__ import annotations

import torch
import jax
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_sigmoid(x, out):
    # src[test_pallas.py:N]: out[tile] = torch.sigmoid(x[tile])
    load = x[...]
    v_0 = jax.nn.sigmoid(load)
    out[...] = v_0

def pallas_sigmoid(x: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = torch.sigmoid(x[tile])
    _launcher(_helion_pallas_sigmoid, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_pointwise_sin)
from __future__ import annotations

import torch
import jax.numpy as jnp
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_sin(x, out):
    # src[test_pallas.py:N]: out[tile] = torch.sin(x[tile])
    load = x[...]
    v_0 = jnp.sin(load)
    out[...] = v_0

def pallas_sin(x: torch.Tensor, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = torch.sin(x[tile])
    _launcher(_helion_pallas_sin, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, out)
    # src[test_pallas.py:N]: return out
    return out

--- assertExpectedJournal(TestPallas.test_scalar_args)
from __future__ import annotations

import torch
import jax.numpy as jnp
import jax.lax as lax
from helion.runtime import default_pallas_launcher as _default_pallas_launcher

def _helion_pallas_affine_scalar_args(x, out, scale, bias):
    # src[test_pallas.py:N]: def pallas_affine_scalar_args(
    # src[test_pallas.py:N]:     x: torch.Tensor,
    # src[test_pallas.py:N]:     scale: int,
    # src[test_pallas.py:N-N]: ...
    scale = scale[...]
    bias = bias[...]
    # src[test_pallas.py:N]: out[tile] = x[tile] * scale + bias
    load = x[...]
    v_0 = lax.convert_element_type(scale, jnp.float32)
    v_1 = load * v_0
    v_2 = v_1 + bias
    out[...] = v_2

def pallas_affine_scalar_args(x: torch.Tensor, scale: int, bias: float, *, _launcher=_default_pallas_launcher):
    # src[test_pallas.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    _BLOCK_SIZE_0 = 256
    # src[test_pallas.py:N]: for tile in hl.tile(out.size()):
    # src[test_pallas.py:N]:     out[tile] = x[tile] * scale + bias
    _launcher(_helion_pallas_affine_scalar_args, ((1024 + _BLOCK_SIZE_0 - 1) // _BLOCK_SIZE_0,), x, out, torch.tensor(scale, device=x.device), torch.tensor(bias, device=x.device))
    # src[test_pallas.py:N]: return out
    return out
