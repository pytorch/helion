This file is automatically generated by assertExpectedJournal calls in test_inline_triton.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_list_args_reuse)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(x, y, out, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    x_val = tl.load(x + indices_0 * 1, None)
    y_val = tl.load(y + indices_0 * 1, None)
    triple = x_val + x_val + x_val
    inline_triton_result = triple + y_val
    tl.static_assert(inline_triton_result.dtype == tl.float32, 'inline_triton output dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result.shape == x_val.shape, 'inline_triton output shape mismatch')
    tl.store(out + indices_0 * 1, inline_triton_result, None)

def kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_launcher):
    out = torch.empty_like(x)
    _BLOCK_SIZE_0 = 16
    _launcher(_helion_kernel, (triton.cdiv(16, _BLOCK_SIZE_0),), x, y, out, _BLOCK_SIZE_0, num_warps=4, num_stages=2)
    return out

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_multi_output)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(a, b, sum_out, diff_out, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    a_val = tl.load(a + indices_0 * 1, None)
    b_val = tl.load(b + indices_0 * 1, None)
    sum_val = a_val + b_val
    diff_val = a_val - b_val
    inline_triton_result = (sum_val, diff_val)
    tl.static_assert(len(inline_triton_result) == 2, 'inline_triton expected 2 outputs')
    tl.static_assert(inline_triton_result[0].dtype == tl.float32, 'inline_triton output 0 dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result[0].shape == a_val.shape, 'inline_triton output 0 shape mismatch')
    tl.static_assert(inline_triton_result[1].dtype == tl.float32, 'inline_triton output 1 dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result[1].shape == a_val.shape, 'inline_triton output 1 shape mismatch')
    sum_val = inline_triton_result[0]
    diff_val = inline_triton_result[1]
    tl.store(sum_out + indices_0 * 1, sum_val, None)
    tl.store(diff_out + indices_0 * 1, diff_val, None)

def kernel(a: torch.Tensor, b: torch.Tensor, *, _launcher=_default_launcher):
    sum_out = torch.empty_like(a)
    diff_out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 64
    _launcher(_helion_kernel, (triton.cdiv(64, _BLOCK_SIZE_0),), a, b, sum_out, diff_out, _BLOCK_SIZE_0, num_warps=4, num_stages=2)
    return (sum_out, diff_out)

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_simple)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(x, y, out, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    x_val = tl.load(x + indices_0 * 1, None)
    y_val = tl.load(y + indices_0 * 1, None)
    tmp = x_val + y_val
    inline_triton_result = tmp
    tl.static_assert(inline_triton_result.dtype == tl.float32, 'inline_triton output dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result.shape == x_val.shape, 'inline_triton output shape mismatch')
    tl.store(out + indices_0 * 1, inline_triton_result, None)

def kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_launcher):
    out = torch.empty_like(x)
    _BLOCK_SIZE_0 = 128
    _launcher(_helion_kernel, (triton.cdiv(128, _BLOCK_SIZE_0),), x, y, out, _BLOCK_SIZE_0, num_warps=4, num_stages=2)
    return out
