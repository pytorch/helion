This file is automatically generated by assertExpectedJournal calls in test_inline_triton.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_list_args_reuse)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(x, y, out, x_size_0, out_stride_0, x_stride_0, y_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < x_size_0
    x_val = tl.load(x + indices_0 * x_stride_0, mask_0, other=0)
    y_val = tl.load(y + indices_0 * y_stride_0, mask_0, other=0)
    triple = x_val + x_val + x_val
    inline_triton_result = triple + y_val
    tl.static_assert(inline_triton_result.dtype == tl.float32, 'inline_triton output dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result.shape == x_val.shape, 'inline_triton output shape mismatch')
    tl.store(out + indices_0 * out_stride_0, inline_triton_result, mask_0)

def kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_launcher):
    out = torch.empty_like(x)
    _BLOCK_SIZE_0 = 16
    _launcher(_helion_kernel, (triton.cdiv(x.size(0), _BLOCK_SIZE_0),), x, y, out, x.size(0), out.stride(0), x.stride(0), y.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_multi_output)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(a, b, sum_out, diff_out, a_size_0, a_stride_0, b_stride_0, diff_out_stride_0, sum_out_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < a_size_0
    a_val = tl.load(a + indices_0 * a_stride_0, mask_0, other=0)
    b_val = tl.load(b + indices_0 * b_stride_0, mask_0, other=0)
    sum_val = a_val + b_val
    diff_val = a_val - b_val
    inline_triton_result = (sum_val, diff_val)
    tl.static_assert(len(inline_triton_result) == 2, 'inline_triton expected 2 outputs')
    tl.static_assert(inline_triton_result[0].dtype == tl.float32, 'inline_triton output 0 dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result[0].shape == a_val.shape, 'inline_triton output 0 shape mismatch')
    tl.static_assert(inline_triton_result[1].dtype == tl.float32, 'inline_triton output 1 dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result[1].shape == a_val.shape, 'inline_triton output 1 shape mismatch')
    sum_val = inline_triton_result[0]
    diff_val = inline_triton_result[1]
    tl.store(sum_out + indices_0 * sum_out_stride_0, sum_val, mask_0)
    tl.store(diff_out + indices_0 * diff_out_stride_0, diff_val, mask_0)

def kernel(a: torch.Tensor, b: torch.Tensor, *, _launcher=_default_launcher):
    sum_out = torch.empty_like(a)
    diff_out = torch.empty_like(a)
    _BLOCK_SIZE_0 = 64
    _launcher(_helion_kernel, (triton.cdiv(a.size(0), _BLOCK_SIZE_0),), a, b, sum_out, diff_out, a.size(0), a.stride(0), b.stride(0), diff_out.stride(0), sum_out.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return (sum_out, diff_out)

--- assertExpectedJournal(TestInlineTriton.test_inline_triton_simple)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel(x, y, out, x_size_0, out_stride_0, x_stride_0, y_stride_0, _BLOCK_SIZE_0: tl.constexpr):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    mask_0 = indices_0 < x_size_0
    x_val = tl.load(x + indices_0 * x_stride_0, mask_0, other=0)
    y_val = tl.load(y + indices_0 * y_stride_0, mask_0, other=0)
    tmp = x_val + y_val
    inline_triton_result = tmp
    tl.static_assert(inline_triton_result.dtype == tl.float32, 'inline_triton output dtype mismatch; expected torch.float32')
    tl.static_assert(inline_triton_result.shape == x_val.shape, 'inline_triton output shape mismatch')
    tl.store(out + indices_0 * out_stride_0, inline_triton_result, mask_0)

def kernel(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_launcher):
    out = torch.empty_like(x)
    _BLOCK_SIZE_0 = 128
    _launcher(_helion_kernel, (triton.cdiv(x.size(0), _BLOCK_SIZE_0),), x, y, out, x.size(0), out.stride(0), x.stride(0), y.stride(0), _BLOCK_SIZE_0, num_warps=4, num_stages=3)
    return out
