This file is automatically generated by assertExpectedJournal calls in test_cute_backend.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestCuteBackend.test_pointwise_add)
from __future__ import annotations

import torch
import cutlass.cute as cute
from helion.runtime import default_cute_launcher as _default_cute_launcher

@cute.kernel
def _helion_cute_add(x, y, out):
    # src[test_cute_backend.py:N]: for tile in hl.tile(out.size()):
    num_blocks_0 = 23
    indices_1 = cute.arch.block_idx()[0] % num_blocks_0
    indices_0 = cute.arch.block_idx()[0] // num_blocks_0
    # src[test_cute_backend.py:N]: out[tile] = x[tile] + y[tile]
    load = x[indices_0, indices_1]
    load_1 = y[indices_0, indices_1]
    v_0 = load + load_1
    out.__setitem__((indices_0, indices_1), v_0)

def cute_add(x: torch.Tensor, y: torch.Tensor, *, _launcher=_default_cute_launcher):
    # src[test_cute_backend.py:N]: x, y = torch.broadcast_tensors(x, y)
    x, y = torch.broadcast_tensors(x, y)
    # src[test_cute_backend.py:N]: out = torch.empty(
    # src[test_cute_backend.py:N]:     x.shape,
    # src[test_cute_backend.py:N]:     dtype=torch.promote_types(x.dtype, y.dtype),
    # src[test_cute_backend.py:N-N]: ...
    out = torch.empty(x.shape, dtype=torch.promote_types(x.dtype, y.dtype), device=x.device)
    # src[test_cute_backend.py:N]: for tile in hl.tile(out.size()):
    # src[test_cute_backend.py:N]:     out[tile] = x[tile] + y[tile]
    _launcher(_helion_cute_add, (23 * 65,), x, y, out, block=(1, 1, 1))
    # src[test_cute_backend.py:N]: return out
    return out

--- assertExpectedJournal(TestCuteBackend.test_pointwise_add_three_inputs)
from __future__ import annotations

import torch
import cutlass.cute as cute
from helion.runtime import default_cute_launcher as _default_cute_launcher

@cute.kernel
def _helion_cute_add3(x, y, z, out):
    # src[test_cute_backend.py:N]: for tile in hl.tile(out.size()):
    num_blocks_0 = 23
    indices_1 = cute.arch.block_idx()[0] % num_blocks_0
    indices_0 = cute.arch.block_idx()[0] // num_blocks_0
    # src[test_cute_backend.py:N]: out[tile] = x[tile] + y[tile] + z[tile]
    load = x[indices_0, indices_1]
    load_1 = y[indices_0, indices_1]
    v_0 = load + load_1
    load_2 = z[indices_0, indices_1]
    v_1 = v_0 + load_2
    out.__setitem__((indices_0, indices_1), v_1)

def cute_add3(x: torch.Tensor, y: torch.Tensor, z: torch.Tensor, *, _launcher=_default_cute_launcher):
    # src[test_cute_backend.py:N]: out = torch.empty_like(x)
    out = torch.empty_like(x)
    # src[test_cute_backend.py:N]: for tile in hl.tile(out.size()):
    # src[test_cute_backend.py:N]:     out[tile] = x[tile] + y[tile] + z[tile]
    _launcher(_helion_cute_add3, (23 * 65,), x, y, z, out, block=(1, 1, 1))
    # src[test_cute_backend.py:N]: return out
    return out
