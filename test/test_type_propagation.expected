This file is automatically generated by assertExpectedJournal calls in test_type_propagation.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestTypePropagation.test_add)
def add(x, y):
    x, y = 
    # Call: SequenceType((TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(broadcast_tensors) AttributeOrigin(value=GlobalOrigin(name='torch'), key='broadcast_tensors')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.broadcast_tensors(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y)
    out = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([5, 5], torch.int32) GetItemOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key=0)
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(5), LiteralType(5))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key='size')
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out.size()):
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile] = 
        # BinOp: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([5, 5], torch.int32) GetItemOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key=0)
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile] + 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([5, 5], torch.int32) GetItemOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key=1)
y[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]
    return 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out

def root_graph_0():
    # File: .../basic_kernels.py:N in add, code: out[tile] = x[tile] + y[tile]
    x: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('x')
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    load: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    y: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('y')
    load_1: "i32[u0, u1]" = helion_language_memory_ops_load(y, [block_size_0, block_size_1], None, None);  y = None
    add: "i32[u0, u1]" = torch.ops.aten.add.Tensor(load, load_1);  load = load_1 = None
    out: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], add, None);  out = block_size_0 = block_size_1 = add = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_all_ast_nodes)
def all_ast_nodes(x, y):
    int_literal = 
    # Constant: LiteralType(1024) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1024
    formatted_value = 
    # JoinedStr: str SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
f'prefix{int_literal}suffix'
    joined_string = 
    # Constant: LiteralType('abc') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'abc'
    list_literal0 = 
    # List: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Name: LiteralType(1024) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
int_literal]
    tuple_literal0 = 
    # Tuple: SequenceType((TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1), LiteralType(2))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1, 
    # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2)
    list_literal1 = 
    # List: SequenceType([LiteralType(5), TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024), LiteralType(3), TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1), LiteralType(2), LiteralType(4)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
5, *
    # Name: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
list_literal0, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3, *
    # Name: SequenceType((TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1), LiteralType(2))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
tuple_literal0, 
    # Constant: LiteralType(4) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
4]
    tuple_literal2 = 
    # List: SequenceType([LiteralType(5), TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024), LiteralType(3), TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1), LiteralType(2), LiteralType(4)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
5, *
    # Name: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
list_literal0, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3, *
    # Name: SequenceType((TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1), LiteralType(2))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
tuple_literal0, 
    # Constant: LiteralType(4) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
4]
    dict_literal0 = 
    # Dict: DictType({1: LiteralType(2)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{}
    
    # Name: DictType({1: LiteralType(2)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
dict_literal0[
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1] = 
    # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2
    dict_literal1 = 
    # Dict: DictType({1: TensorType([5, 5], torch.int32), 'y': TensorType([5, 5], torch.int32)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1: 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Constant: LiteralType('y') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'y': 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y}
    dict_literal2 = 
    # Dict: DictType({'foo': LiteralType('bar'), 1: TensorType([5, 5], torch.int32), 'y': TensorType([5, 5], torch.int32)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{
    # Constant: LiteralType('foo') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'foo': 
    # Constant: LiteralType('bar') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'bar', **
    # Name: DictType({1: TensorType([5, 5], torch.int32), 'y': TensorType([5, 5], torch.int32)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
dict_literal1}
    uadd = 
    # UnaryOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
+
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
    usub = 
    # UnaryOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
-
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
    invert = 
    # UnaryOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
~
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
    not_ = 
    # UnaryOp: SymBoolType(Eq(u0, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
not 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
    add = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x + 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    sub = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x - 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    mul = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x * 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    truediv = 
    # BinOp: TensorType([5, 5], torch.float32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x / 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    floordiv = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x // 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    mod = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x % 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    pow = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x ** 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    lshift = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x << 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    rshift = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x >> 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    bitwise_and = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x & 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    bitwise_xor = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x ^ 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    bitwise_or = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x | 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    eq = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x == 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    ne = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x != 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    lt = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x < 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    le = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x <= 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    gt = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x > 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    ge = 
    # Compare: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x >= 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    is_ = 
    # Compare: SymBoolType(Eq(u1, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x is 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    is_not = 
    # Compare: SymBoolType(Eq(u2, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x is not 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    in_ = 
    # Compare: SymBoolType(Eq(u3, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x in 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    not_in = 
    # Compare: SymBoolType(Eq(u4, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x not in 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    call0 = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: CallableType(func) AttributeOrigin(value=GlobalOrigin(name='_source_module'), key='func')
func(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3)
    call1 = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: CallableType(func) AttributeOrigin(value=GlobalOrigin(name='_source_module'), key='func')
func(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, c=
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3)
    call2 = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: CallableType(func) AttributeOrigin(value=GlobalOrigin(name='_source_module'), key='func')
func(*
    # Tuple: SequenceType((TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y))
    call3 = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: CallableType(func) AttributeOrigin(value=GlobalOrigin(name='_source_module'), key='func')
func(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x, **
    # Dict: DictType({'b': TensorType([5, 5], torch.int32), 'c': TensorType([5, 5], torch.int32)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{
    # Constant: LiteralType('b') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'b': 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Constant: LiteralType('c') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'c': 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y})
    ifexp = 
    # IfExp: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x if 
    # Name: TensorType([5, 5], torch.bool) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
eq else 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    attr0 = 
    # Attribute: LiteralType(torch.int32) AttributeOrigin(value=ArgumentOrigin(name='x'), key='dtype')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.dtype
    attr1 = 
    # Attribute: SequenceType((LiteralType(5), LiteralType(5))) AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.shape
    attr2 = 
    # Call: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='size')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.size(
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0)
    attr3 = 
    # Call: SequenceType((LiteralType(5), LiteralType(5))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='size')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.size()
    attr4 = 
    # Call: SequenceType((LiteralType(5), LiteralType(1))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='stride')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.stride()
    attr5 = 
    # Call: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='stride')
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x.stride(
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0)
    named_expr = 
    # NamedExpr: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
(z := 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y + 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1))
    zzz = zz = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
z - 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1
    q = 
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
zzz + 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
zz + 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
z
    subscript0 = 
    # Subscript: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
    # Name: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
list_literal0[
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0]
    subscript1 = 
    # Subscript: SequenceType([TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
list_literal0[
    # Slice: SliceType(LiteralType(1):LiteralType(None):LiteralType(None)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1:]
    subscript2 = 
    # Subscript: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), LiteralType(1024)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
list_literal0[
    # Slice: SliceType(LiteralType(None):LiteralType(-1):LiteralType(None)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
:
    # UnaryOp: LiteralType(-1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
-
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1]
    add += 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    add -= 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    a, b, c = 
    # List: SequenceType([LiteralType(1), LiteralType(2), LiteralType(3)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1, 
    # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3]
    tmp0 = 
    # List: SequenceType([LiteralType(1), LiteralType(2), LiteralType(3)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
a, 
    # Name: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
b, 
    # Name: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
c]
    a, *bc = 
    # List: SequenceType([LiteralType(1), LiteralType(2), LiteralType(3), LiteralType(4)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1, 
    # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3, 
    # Constant: LiteralType(4) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
4]
    tmp1 = 
    # List: SequenceType([LiteralType(2), LiteralType(3), LiteralType(4), LiteralType(1)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[*
    # Name: SequenceType([LiteralType(2), LiteralType(3), LiteralType(4)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
bc, 
    # Name: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
a]
    a, *ab, c = 
    # List: SequenceType([LiteralType(1), LiteralType(2), LiteralType(3), LiteralType(4)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1, 
    # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2, 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3, 
    # Constant: LiteralType(4) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
4]
    tmp2 = 
    # List: SequenceType([LiteralType(1), LiteralType(4), LiteralType(2), LiteralType(3)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
a, 
    # Name: LiteralType(4) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
c, *
    # Name: SequenceType([LiteralType(2), LiteralType(3)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
ab]
    a, *ab, c = 
    # List: SequenceType([LiteralType(5), LiteralType(6)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Constant: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
5, 
    # Constant: LiteralType(6) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
6]
    tmp2 = 
    # List: SequenceType([LiteralType(5), LiteralType(6)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: LiteralType(5) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
a, 
    # Name: LiteralType(6) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
c, *
    # Name: SequenceType([]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
ab]
    e0 = 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1
    e1 = 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1
    e2 = 
    # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1
    assert 
    # Compare: SymBoolType(Eq(u5, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x is not 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
    assert 
    # Compare: SymBoolType(Eq(u6, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x is not 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y, 
    # Constant: LiteralType('msg') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'msg'
    if 
    # Compare: SymBoolType(Eq(u7, 1)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x is 
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y:
        join_var0 = 
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
        join_var1 = 
        # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x + 
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
        join_var2 = 
        # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1
        join_var3 = 
        # Dict: DictType({'x': LiteralType(0)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{
        # Constant: LiteralType('x') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'x': 
        # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0}
    else:
        join_var0 = 
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
        join_var1 = 
        # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x - 
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y
        join_var2 = 
        # Constant: LiteralType(2) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
2
        join_var3 = 
        # Dict: DictType({'x': LiteralType(1)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
{
        # Constant: LiteralType('x') SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
'x': 
        # Constant: LiteralType(1) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
1}
    combined = 
    # List: SequenceType([TensorType([5, 5], torch.int32), TensorType([5, 5], torch.int32), SymIntType(u8), DictType({'x': SymIntType(u9)})]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
join_var0, 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
join_var1, 
    # Name: SymIntType(u8) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
join_var2, 
    # Name: DictType({'x': SymIntType(u9)}) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
join_var3]
    i = 
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3
    t = 
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0
    global global0
    out = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x)
    v = 
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0
    z = 
    # Call: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.zeros_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='zeros_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.zeros_like(
    # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(5), LiteralType(5))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>), key='size')
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
out.size()):
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
tile] = 
        # BinOp: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
tile] + 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='y')
y[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
tile]
    # For: loop_type=HOST

    for i in 
    # Call: LiteralType(range(0, 3)) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
    # Name: CallableType(range) BuiltinOrigin(name='range')
range(
    # Constant: LiteralType(3) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
3):
        v = 
        # BinOp: SymIntType(u15) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: SymIntType(u14) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
v + 
        # Name: SymIntType(u13) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
i
        z = 
        # BinOp: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
        # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
z + 
        # Name: TensorType([5, 5], torch.int32) ArgumentOrigin(name='x')
x
    else:
        t = 
        # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
0
    combined = 
    # List: SequenceType([SymIntType(u16), TensorType([5, 5], torch.int32)]) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
[
    # Name: SymIntType(u16) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
v, 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
z]
    return 
    # Name: TensorType([5, 5], torch.int32) SourceOrigin(location=<SourceLocation all_ast_nodes.py:N>)
out

def root_graph_0():
    # File: .../all_ast_nodes.py:N in all_ast_nodes, code: out[tile] = x[tile] + y[tile]
    x: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('x')
    block_size_0: "Sym(u10)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u11)" = helion_language__tracing_ops__get_symnode('block_size_1')
    load: "i32[u10, u11]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    y: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('y')
    load_1: "i32[u10, u11]" = helion_language_memory_ops_load(y, [block_size_0, block_size_1], None, None);  y = None
    add: "i32[u10, u11]" = torch.ops.aten.add.Tensor(load, load_1);  load = load_1 = None
    out: "i32[5, 5]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], add, None);  out = block_size_0 = block_size_1 = add = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_and_between_optional_tensors)
def kernel(t: torch.Tensor, c: torch.Tensor | None=None, d: torch.Tensor | None=None):
    a = 
    # Call: TensorType([16], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([16], torch.float32) ArgumentOrigin(name='t')
t)
    # For: loop_type=GRID

    for h in 
    # Call: IterType(TileIndexType(0)) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: LiteralType(16) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation test_type_propagation.py:N>), key='size')
    # Name: TensorType([16], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
a.size(
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
0)):
        if 
        # BoolOp: LiteralType(False) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Compare: LiteralType(False) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Name: LiteralType(None) ArgumentOrigin(name='c')
c is not 
        # Constant: LiteralType(None) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
None and 
        # Compare: LiteralType(False) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Name: LiteralType(None) ArgumentOrigin(name='d')
d is not 
        # Constant: LiteralType(None) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
None:
            a[h] = t[h] + c[h] + d[h]
        else:
            
            # Subscript: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
            # Name: TensorType([16], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
a[
            # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
h] = 
            # Subscript: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
            # Name: TensorType([16], torch.float32) ArgumentOrigin(name='t')
t[
            # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
h]
    return 
    # Name: TensorType([16], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
a

def root_graph_0():
    # File: .../test_type_propagation.py:N in kernel, code: a[h] = t[h]
    t: "f32[16]" = helion_language__tracing_ops__host_tensor('t')
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    load: "f32[u0]" = helion_language_memory_ops_load(t, [block_size_0], None, None);  t = None
    a: "f32[16]" = helion_language__tracing_ops__host_tensor('a')
    store = helion_language_memory_ops_store(a, [block_size_0], load, None);  a = block_size_0 = load = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_cuda_device_properties)
def use_device_properties(x: torch.Tensor):
    device = 
    # Attribute: LiteralType(device=DEVICE) AttributeOrigin(value=ArgumentOrigin(name='x'), key='device')
    # Name: TensorType([128], torch.float32) ArgumentOrigin(name='x')
x.device
    props = 
    # Call: ClassType({'multi_processor_count': SymIntType(u0)}) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(get_device_properties) AttributeOrigin(value=AttributeOrigin(value=GlobalOrigin(name='torch'), key='cuda'), key='get_device_properties')
    # Attribute: PythonModuleType(torch.cuda) AttributeOrigin(value=GlobalOrigin(name='torch'), key='cuda')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.cuda.get_device_properties(
    # Name: LiteralType(device=DEVICE) AttributeOrigin(value=ArgumentOrigin(name='x'), key='device')
device)
    sm_count = 
    # Attribute: SymIntType(u0) AttributeOrigin(value=SourceOrigin(location=<SourceLocation test_type_propagation.py:N>), key='multi_processor_count')
    # Name: ClassType({'multi_processor_count': SymIntType(u0)}) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
props.multi_processor_count
    n = 
    # Subscript: LiteralType(128) GetItemOrigin(value=AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape'), key=0)
    # Attribute: SequenceType((LiteralType(128), )) AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape')
    # Name: TensorType([128], torch.float32) ArgumentOrigin(name='x')
x.shape[
    # Constant: LiteralType(0) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
0]
    out = 
    # Call: TensorType([128], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.zeros_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='zeros_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.zeros_like(
    # Name: TensorType([128], torch.float32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for worker_id in 
    # Call: IterType(GridIndexType(0)) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(grid) AttributeOrigin(value=GlobalOrigin(name='hl'), key='grid')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.grid(
    # Name: SymIntType(u0) AttributeOrigin(value=SourceOrigin(location=<SourceLocation test_type_propagation.py:N>), key='multi_processor_count')
sm_count):
        # For: loop_type=DEVICE

        for i in 
        # Call: IterType(GridIndexType(1)) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Attribute: CallableType(grid) AttributeOrigin(value=GlobalOrigin(name='hl'), key='grid')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.grid(
        # Name: LiteralType(128) GetItemOrigin(value=AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape'), key=0)
n):
            idx = 
            # BinOp: SymIntType(u0*u4 + u2) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
            # Name: GridIndexType(0) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
worker_id + 
            # BinOp: SymIntType(u0*u4) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
            # Name: GridIndexType(1) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
i * 
            # Name: SymIntType(u0) AttributeOrigin(value=SourceOrigin(location=<SourceLocation test_type_propagation.py:N>), key='multi_processor_count')
sm_count
            if 
            # Compare: SymBoolType(Eq(u11, 1)) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
            # Name: SymIntType(u0*u4 + u2) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
idx < 
            # Name: LiteralType(128) GetItemOrigin(value=AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape'), key=0)
n:
                
                # Subscript: TensorType([], torch.float32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
                # Name: TensorType([128], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
out[
                # Name: SymIntType(u0*u4 + u2) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
idx] = 
                # Subscript: TensorType([], torch.float32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
                # Name: TensorType([128], torch.float32) ArgumentOrigin(name='x')
x[
                # Name: SymIntType(u0*u4 + u2) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
idx]
    return 
    # Name: TensorType([128], torch.float32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
out

def if_else_graph_0():
    # File: .../test_type_propagation.py:N in use_device_properties, code: out[idx] = x[idx]
    x: "f32[128]" = helion_language__tracing_ops__host_tensor('x')
    symnode: "Sym(u0*u4 + u2)" = helion_language__tracing_ops__get_symnode('u0*u4 + u2')
    load: "f32[]" = helion_language_memory_ops_load(x, [symnode], None, None);  x = None
    out: "f32[128]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [symnode], load, None);  out = symnode = load = store = None
    return []

def for_loop_1():
    # File: .../test_type_propagation.py:N in use_device_properties, code: idx = worker_id + i * sm_count
    u4: "Sym(u4)" = helion_language__tracing_ops__get_symnode('u4')
    u0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('u0')
    mul: "Sym(u0*u4)" = u4 * u0;  u4 = u0 = None
    u2: "Sym(u2)" = helion_language__tracing_ops__get_symnode('u2')
    add: "Sym(u0*u4 + u2)" = u2 + mul;  u2 = mul = None

    # File: .../test_type_propagation.py:N in use_device_properties, code: if idx < n:
    lt: "Sym(u0*u4 + u2 < 128)" = add < 128;  add = None
    _if = helion_language__tracing_ops__if(lt, 0, []);  lt = _if = None
    return []

def root_graph_2():
    # File: .../test_type_propagation.py:N in use_device_properties, code: for i in hl.grid(n):
    _for_loop = helion_language__tracing_ops__for_loop(1, [0], [128], []);  _for_loop = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_hl_full_usage)
def hl_full_usage(x: torch.Tensor):
    out = 
    # Call: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(512), LiteralType(512))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key='size')
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out.size()):
        tmp = 
        # Call: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(full) AttributeOrigin(value=GlobalOrigin(name='hl'), key='full')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.full(
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile, 
        # Constant: LiteralType(1) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
1, dtype=
        # Attribute: LiteralType(torch.int32) AttributeOrigin(value=ArgumentOrigin(name='x'), key='dtype')
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x.dtype)
        tmp += 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]
        tmp += 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile] = 
        # Name: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
tmp
    return 
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out

def root_graph_0():
    # File: .../basic_kernels.py:N in hl_full_usage, code: tmp = hl.full(tile, 1, dtype=x.dtype)
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    tmp: "i32[u0, u1]" = helion_language_creation_ops_full((block_size_0, block_size_1), 1, torch.int32, None)

    # File: .../basic_kernels.py:N in hl_full_usage, code: tmp += x[tile]
    x: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('x')
    load: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None)
    tmp_1: "i32[u0, u1]" = torch.ops.aten.add.Tensor(tmp, load);  tmp = load = None

    # File: .../basic_kernels.py:N in hl_full_usage, code: tmp += x[tile]
    load_1: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    tmp_2: "i32[u0, u1]" = torch.ops.aten.add.Tensor(tmp_1, load_1);  tmp_1 = load_1 = None

    # File: .../basic_kernels.py:N in hl_full_usage, code: out[tile] = tmp
    out: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], tmp_2, None);  out = block_size_0 = block_size_1 = tmp_2 = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_hl_zeros_usage)
def hl_zeros_usage(x: torch.Tensor):
    out = 
    # Call: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(512), LiteralType(512))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key='size')
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out.size()):
        tmp = 
        # Call: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(zeros) AttributeOrigin(value=GlobalOrigin(name='hl'), key='zeros')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.zeros(
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile, dtype=
        # Attribute: LiteralType(torch.int32) AttributeOrigin(value=ArgumentOrigin(name='x'), key='dtype')
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x.dtype)
        tmp += 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]
        tmp += 
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile] = 
        # Name: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
tmp
    return 
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out

def root_graph_0():
    # File: .../basic_kernels.py:N in hl_zeros_usage, code: tmp = hl.zeros(tile, dtype=x.dtype)
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    tmp: "i32[u0, u1]" = helion_language_creation_ops_full((block_size_0, block_size_1), 0, torch.int32, None)

    # File: .../basic_kernels.py:N in hl_zeros_usage, code: tmp += x[tile]
    x: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('x')
    load: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None)
    tmp_1: "i32[u0, u1]" = torch.ops.aten.add.Tensor(tmp, load);  tmp = load = None

    # File: .../basic_kernels.py:N in hl_zeros_usage, code: tmp += x[tile]
    load_1: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    tmp_2: "i32[u0, u1]" = torch.ops.aten.add.Tensor(tmp_1, load_1);  tmp_1 = load_1 = None

    # File: .../basic_kernels.py:N in hl_zeros_usage, code: out[tile] = tmp
    out: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], tmp_2, None);  out = block_size_0 = block_size_1 = tmp_2 = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_matmul)
def matmul(x: Tensor, y: Tensor, epilogue: Callable[[Tensor, tuple[Tensor, ...]], Tensor]=lambda acc, tile: acc):
    """
    Performs matrix multiplication of x and y with an optional epilogue function.
    Args:
        x (Tensor): Left matrix of shape [m, k].
        y (Tensor): Right matrix of shape [k, n].
        epilogue (Callable, optional): Function applied to the accumulator and tile indices
            after the matmul. Defaults to identity (no change).
    Returns:
        Tensor: Resulting matrix of shape [m, n].
    """
    m, k = 
    # Call: SequenceType((LiteralType(512), LiteralType(512))) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='size')
    # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='x')
x.size()
    k2, n = 
    # Call: SequenceType((LiteralType(512), LiteralType(512))) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='y'), key='size')
    # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='y')
y.size()
    assert 
    # Compare: LiteralType(True) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=1)
k == 
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=0)
k2, 
    # JoinedStr: str SourceOrigin(location=<SourceLocation matmul.py:N>)
f'size mismatch {k} != {k2}'
    out = 
    # Call: TensorType([512, 512], torch.float32) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty(
    # List: SequenceType([LiteralType(512), LiteralType(512)]) SourceOrigin(location=<SourceLocation matmul.py:N>)
[
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=0)
m, 
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=1)
n], dtype=
    # Call: LiteralType(torch.float32) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.promote_types) AttributeOrigin(value=GlobalOrigin(name='torch'), key='promote_types')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.promote_types(
    # Attribute: LiteralType(torch.float32) AttributeOrigin(value=ArgumentOrigin(name='x'), key='dtype')
    # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='x')
x.dtype, 
    # Attribute: LiteralType(torch.float32) AttributeOrigin(value=ArgumentOrigin(name='y'), key='dtype')
    # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='y')
y.dtype), device=
    # Attribute: LiteralType(device=DEVICE) AttributeOrigin(value=ArgumentOrigin(name='x'), key='device')
    # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='x')
x.device)
    # For: loop_type=GRID

    for tile_m, tile_n in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation matmul.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # List: SequenceType([LiteralType(512), LiteralType(512)]) SourceOrigin(location=<SourceLocation matmul.py:N>)
[
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=0)
m, 
    # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=1)
n]):
        acc = 
        # Call: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
        # Attribute: CallableType(zeros) AttributeOrigin(value=GlobalOrigin(name='hl'), key='zeros')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.zeros(
        # List: SequenceType([TileIndexType(0), TileIndexType(1)]) DeviceOrigin(location=<SourceLocation matmul.py:N>)
[
        # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_m, 
        # Name: TileIndexType(1) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_n], dtype=
        # Attribute: LiteralType(torch.float32) AttributeOrigin(value=GlobalOrigin(name='torch'), key='float32')
        # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.float32)
        # For: loop_type=DEVICE

        for tile_k in 
        # Call: IterType(TileIndexType(2)) DeviceOrigin(location=<SourceLocation matmul.py:N>)
        # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
        # Name: LiteralType(512) GetItemOrigin(value=SourceOrigin(location=<SourceLocation matmul.py:N>), key=1)
k):
            acc = 
            # Call: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
            # Attribute: CallableType(_VariableFunctionsClass.addmm) AttributeOrigin(value=GlobalOrigin(name='torch'), key='addmm')
            # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.addmm(
            # Name: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
acc, 
            # Subscript: TensorType([block_size_0, block_size_2], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
            # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='x')
x[
            # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_m, 
            # Name: TileIndexType(2) DeviceOrigin(location=<SourceLocation matmul.py:N>)
tile_k], 
            # Subscript: TensorType([block_size_2, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
            # Name: TensorType([512, 512], torch.float32) ArgumentOrigin(name='y')
y[
            # Name: TileIndexType(2) DeviceOrigin(location=<SourceLocation matmul.py:N>)
tile_k, 
            # Name: TileIndexType(1) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_n])
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
        # Name: TensorType([512, 512], torch.float32) SourceOrigin(location=<SourceLocation matmul.py:N>)
out[
        # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_m, 
        # Name: TileIndexType(1) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_n] = 
        # Call: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
        # Name: CallableType(<lambda>) ArgumentOrigin(name='epilogue')
epilogue(
        # Name: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation matmul.py:N>)
acc, 
        # Tuple: SequenceType((TileIndexType(0), TileIndexType(1))) DeviceOrigin(location=<SourceLocation matmul.py:N>)
(
        # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_m, 
        # Name: TileIndexType(1) SourceOrigin(location=<SourceLocation matmul.py:N>)
tile_n))
    return 
    # Name: TensorType([512, 512], torch.float32) SourceOrigin(location=<SourceLocation matmul.py:N>)
out

def for_loop_0(arg0_1: "f32[u0, u1]"):
    # File: .../matmul.py:N in matmul, code: for tile_k in hl.tile(k):
    _new_var: "f32[u0, u1]" = helion_language__tracing_ops__new_var(arg0_1)

    # File: .../matmul.py:N in matmul, code: acc = torch.addmm(acc, x[tile_m, tile_k], y[tile_k, tile_n])
    x: "f32[512, 512]" = helion_language__tracing_ops__host_tensor('x')
    sym_size_int: "Sym(u0)" = torch.ops.aten.sym_size.int(arg0_1, 0)
    block_size_2: "Sym(u2)" = helion_language__tracing_ops__get_symnode('block_size_2')
    load: "f32[u0, u2]" = helion_language_memory_ops_load(x, [sym_size_int, block_size_2], None, None);  x = sym_size_int = None
    y: "f32[512, 512]" = helion_language__tracing_ops__host_tensor('y')
    sym_size_int_1: "Sym(u1)" = torch.ops.aten.sym_size.int(arg0_1, 1);  arg0_1 = None
    load_1: "f32[u2, u1]" = helion_language_memory_ops_load(y, [block_size_2, sym_size_int_1], None, None);  y = block_size_2 = sym_size_int_1 = None
    acc: "f32[u0, u1]" = torch.ops.aten.addmm.default(_new_var, load, load_1);  _new_var = load = load_1 = None
    return [acc]

def root_graph_1():
    # File: .../matmul.py:N in matmul, code: acc = hl.zeros([tile_m, tile_n], dtype=torch.float32)
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    acc: "f32[u0, u1]" = helion_language_creation_ops_full([block_size_0, block_size_1], 0.0, torch.float32, None)

    # File: .../matmul.py:N in matmul, code: for tile_k in hl.tile(k):
    _for_loop = helion_language__tracing_ops__for_loop(0, [0], [512], [acc])
    getitem: "f32[u0, u1]" = _for_loop[0];  _for_loop = None
    _phi: "f32[u0, u1]" = helion_language__tracing_ops__phi(acc, getitem);  acc = getitem = None

    # File: .../matmul.py:N in matmul, code: out[tile_m, tile_n] = epilogue(acc, (tile_m, tile_n))
    out: "f32[512, 512]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], _phi, None);  out = block_size_0 = block_size_1 = _phi = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_method_call)
def fn(x):
    out = 
    # Call: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), TileIndexType(1)))) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(512), LiteralType(512))) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=ArgumentOrigin(name='x'), key='size')
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x.size()):
        
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
tile] = 
        # Call: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Attribute: TensorAttributeType AttributeOrigin(value=DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>), key='sin')
        # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation test_type_propagation.py:N>)
        # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), TileIndexType(1))) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
tile].sin()
    return 
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation test_type_propagation.py:N>)
out

def root_graph_0():
    # File: .../test_type_propagation.py:N in fn, code: out[tile] = x[tile].sin()
    x: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('x')
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    load: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    sin: "f32[u0, u1]" = torch.ops.aten.sin.default(load);  load = None
    convert_element_type: "i32[u0, u1]" = torch.ops.prims.convert_element_type.default(sin, torch.int32);  sin = None
    out: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], convert_element_type, None);  out = block_size_0 = block_size_1 = convert_element_type = store = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_pointwise_device_loop)
def pointwise_device_loop(x: torch.Tensor):
    out = 
    # Call: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x)
    n, m = 
    # Attribute: SequenceType((LiteralType(512), LiteralType(512))) AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape')
    # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x.shape
    # For: loop_type=GRID

    for tile_n in 
    # Call: IterType(TileIndexType(0)) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Name: LiteralType(512) GetItemOrigin(value=AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape'), key=0)
n):
        # For: loop_type=DEVICE

        for tile_m in 
        # Call: IterType(TileIndexType(1)) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
        # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
        # Name: LiteralType(512) GetItemOrigin(value=AttributeOrigin(value=ArgumentOrigin(name='x'), key='shape'), key=1)
m):
            
            # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
            # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out[
            # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile_n, 
            # Name: TileIndexType(1) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile_m] = 
            # Call: TensorType([block_size_0, block_size_1], torch.float32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
            # Attribute: CallableType(_VariableFunctionsClass.sigmoid) AttributeOrigin(value=GlobalOrigin(name='torch'), key='sigmoid')
            # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.sigmoid(
            # BinOp: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
            # Subscript: TensorType([block_size_0, block_size_1], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
            # Name: TensorType([512, 512], torch.int32) ArgumentOrigin(name='x')
x[
            # Name: TileIndexType(0) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile_n, 
            # Name: TileIndexType(1) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile_m] + 
            # Constant: LiteralType(1) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
1)
    return 
    # Name: TensorType([512, 512], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out

def for_loop_0():
    # File: .../basic_kernels.py:N in pointwise_device_loop, code: out[tile_n, tile_m] = torch.sigmoid(x[tile_n, tile_m] + 1)
    x: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('x')
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    block_size_1: "Sym(u1)" = helion_language__tracing_ops__get_symnode('block_size_1')
    load: "i32[u0, u1]" = helion_language_memory_ops_load(x, [block_size_0, block_size_1], None, None);  x = None
    add: "i32[u0, u1]" = torch.ops.aten.add.Tensor(load, 1);  load = None
    sigmoid: "f32[u0, u1]" = torch.ops.aten.sigmoid.default(add);  add = None
    convert_element_type: "i32[u0, u1]" = torch.ops.prims.convert_element_type.default(sigmoid, torch.int32);  sigmoid = None
    out: "i32[512, 512]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0, block_size_1], convert_element_type, None);  out = block_size_0 = block_size_1 = convert_element_type = store = None
    return []

def root_graph_1():
    # File: .../basic_kernels.py:N in pointwise_device_loop, code: for tile_m in hl.tile(m):
    _for_loop = helion_language__tracing_ops__for_loop(0, [0], [512], []);  _for_loop = None
    return None

--- assertExpectedJournal(TestTypePropagation.test_torch_ops_pointwise)
def torch_ops_pointwise(x, y):
    out = 
    # Call: TensorType([1024], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(_VariableFunctionsClass.empty_like) AttributeOrigin(value=GlobalOrigin(name='torch'), key='empty_like')
    # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.empty_like(
    # Name: TensorType([1024], torch.int32) ArgumentOrigin(name='x')
x)
    # For: loop_type=GRID

    for tile in 
    # Call: IterType(SequenceType((TileIndexType(0), ))) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: CallableType(tile) AttributeOrigin(value=GlobalOrigin(name='hl'), key='tile')
    # Name: PythonModuleType(helion.language) GlobalOrigin(name='hl')
hl.tile(
    # Call: SequenceType((LiteralType(1024), )) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
    # Attribute: TensorAttributeType AttributeOrigin(value=SourceOrigin(location=<SourceLocation basic_kernels.py:N>), key='size')
    # Name: TensorType([1024], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out.size()):
        
        # Subscript: TensorType([block_size_0], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([1024], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out[
        # Name: SequenceType((TileIndexType(0), )) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile] = 
        # Call: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(_VariableFunctionsClass.sigmoid) AttributeOrigin(value=GlobalOrigin(name='torch'), key='sigmoid')
        # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.sigmoid(
        # Call: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(_VariableFunctionsClass.add) AttributeOrigin(value=GlobalOrigin(name='torch'), key='add')
        # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.add(
        # Call: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(_VariableFunctionsClass.sin) AttributeOrigin(value=GlobalOrigin(name='torch'), key='sin')
        # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.sin(
        # Subscript: TensorType([block_size_0], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([1024], torch.int32) ArgumentOrigin(name='x')
x[
        # Name: SequenceType((TileIndexType(0), )) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile]), 
        # Call: TensorType([block_size_0], torch.float32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Attribute: CallableType(_VariableFunctionsClass.cos) AttributeOrigin(value=GlobalOrigin(name='torch'), key='cos')
        # Name: PythonModuleType(torch) GlobalOrigin(name='torch')
torch.cos(
        # Subscript: TensorType([block_size_0], torch.int32) DeviceOrigin(location=<SourceLocation basic_kernels.py:N>)
        # Name: TensorType([1024], torch.int32) ArgumentOrigin(name='y')
y[
        # Name: SequenceType((TileIndexType(0), )) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
tile])))
    return 
    # Name: TensorType([1024], torch.int32) SourceOrigin(location=<SourceLocation basic_kernels.py:N>)
out

def root_graph_0():
    # File: .../basic_kernels.py:N in torch_ops_pointwise, code: out[tile] = torch.sigmoid(torch.add(torch.sin(x[tile]), torch.cos(y[tile])))
    x: "i32[1024]" = helion_language__tracing_ops__host_tensor('x')
    block_size_0: "Sym(u0)" = helion_language__tracing_ops__get_symnode('block_size_0')
    load: "i32[u0]" = helion_language_memory_ops_load(x, [block_size_0], None, None);  x = None
    sin: "f32[u0]" = torch.ops.aten.sin.default(load);  load = None
    y: "i32[1024]" = helion_language__tracing_ops__host_tensor('y')
    load_1: "i32[u0]" = helion_language_memory_ops_load(y, [block_size_0], None, None);  y = None
    cos: "f32[u0]" = torch.ops.aten.cos.default(load_1);  load_1 = None
    add: "f32[u0]" = torch.ops.aten.add.Tensor(sin, cos);  sin = cos = None
    sigmoid: "f32[u0]" = torch.ops.aten.sigmoid.default(add);  add = None
    convert_element_type: "i32[u0]" = torch.ops.prims.convert_element_type.default(sigmoid, torch.int32);  sigmoid = None
    out: "i32[1024]" = helion_language__tracing_ops__host_tensor('out')
    store = helion_language_memory_ops_store(out, [block_size_0], convert_element_type, None);  out = block_size_0 = convert_element_type = store = None
    return None
