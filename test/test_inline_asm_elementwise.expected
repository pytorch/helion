This file is automatically generated by assertExpectedJournal calls in test_inline_asm_elementwise.py.
Update expected outputs by running tests with the EXPECTTEST_ACCEPT=1 environment variable set.

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_basic_compilation)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_basic(x, result, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: [x[tile]],
    load = tl.load(x + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     "mov.u32 $0, $1;",
    # src[test_inline_asm_elementwise.py:N]:     "=r,r",
    # src[test_inline_asm_elementwise.py:N-N]: ...
    result_val = tl.inline_asm_elementwise('mov.u32 $0, $1;', '=r,r', [load], tl.int32, True, 1)
    # src[test_inline_asm_elementwise.py:N]: result[tile] = result_val
    tl.store(result + indices_0 * 1, result_val, None)

def kernel_basic(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result = torch.empty_like(x)
    result = torch.empty_like(x)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    _BLOCK_SIZE_0 = 16
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    # src[test_inline_asm_elementwise.py:N]:     # Simple compilation test
    # src[test_inline_asm_elementwise.py:N]:     result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_basic, (triton.cdiv(16, _BLOCK_SIZE_0),), x, result, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result
    return result

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_empty_args)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_empty_args(result, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     "mov.u32 $0, 42;",  # No input registers, just output constant
    # src[test_inline_asm_elementwise.py:N]:     "=r",  # Only output constraint
    # src[test_inline_asm_elementwise.py:N-N]: ...
    result_val = tl.inline_asm_elementwise('mov.u32 $0, 42;', '=r', [], tl.int32, True, 1)
    # src[test_inline_asm_elementwise.py:N]: result[tile] = result_val
    tl.store(result + indices_0 * 1, result_val, None)

def kernel_empty_args(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result = torch.empty_like(x)
    result = torch.empty_like(x)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    _BLOCK_SIZE_0 = 16
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    # src[test_inline_asm_elementwise.py:N]:     # Empty args should work - generates output with context shape
    # src[test_inline_asm_elementwise.py:N]:     result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_empty_args, (triton.cdiv(16, _BLOCK_SIZE_0),), result, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result
    return result

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_multiple_outputs)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_multiple_outputs(a, b, result_c, result_d, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(a.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: val_a = a[tile]
    val_a = tl.load(a + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: val_b = b[tile]
    val_b = tl.load(b + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: c_val, d_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     """
    # src[test_inline_asm_elementwise.py:N]:     sub.u32 $0, $2, $3;
    # src[test_inline_asm_elementwise.py:N-N]: ...
    c_val = tl.inline_asm_elementwise('\n            sub.u32 $0, $2, $3;\n            sub.u32 $1, $3, $2;\n            ', '=r,=r,r,r', [val_a, val_b], (tl.int32, tl.int32), True, 1)[0]
    d_val = tl.inline_asm_elementwise('\n            sub.u32 $0, $2, $3;\n            sub.u32 $1, $3, $2;\n            ', '=r,=r,r,r', [val_a, val_b], (tl.int32, tl.int32), True, 1)[1]
    # src[test_inline_asm_elementwise.py:N]: result_c[tile] = c_val
    tl.store(result_c + indices_0 * 1, c_val, None)
    # src[test_inline_asm_elementwise.py:N]: result_d[tile] = d_val
    tl.store(result_d + indices_0 * 1, d_val, None)

def kernel_multiple_outputs(a: torch.Tensor, b: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result_c = torch.empty_like(a)
    result_c = torch.empty_like(a)
    # src[test_inline_asm_elementwise.py:N]: result_d = torch.empty_like(a)
    result_d = torch.empty_like(a)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(a.shape):
    _BLOCK_SIZE_0 = 32
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(a.shape):
    # src[test_inline_asm_elementwise.py:N]:     val_a = a[tile]
    # src[test_inline_asm_elementwise.py:N]:     val_b = b[tile]
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_multiple_outputs, (triton.cdiv(64, _BLOCK_SIZE_0),), a, b, result_c, result_d, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result_c, result_d
    return (result_c, result_d)

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_packed)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_packed_asm(x, result, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: val = x[tile]
    val = tl.load(x + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     "and.b32 $0, $1, 0x1F1F1F1F; shl.b32 $0, $0, 3;",
    # src[test_inline_asm_elementwise.py:N]:     "=r,r",
    # src[test_inline_asm_elementwise.py:N-N]: ...
    result_val = tl.inline_asm_elementwise('and.b32 $0, $1, 0x1F1F1F1F; shl.b32 $0, $0, 3;', '=r,r', [val], tl.int8, True, 4)
    # src[test_inline_asm_elementwise.py:N]: result[tile] = result_val
    v_0 = tl.cast(result_val, tl.uint8)
    tl.store(result + indices_0 * 1, v_0, None)

def kernel_packed_asm(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result = torch.empty_like(x)
    result = torch.empty_like(x)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    _BLOCK_SIZE_0 = 32
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    # src[test_inline_asm_elementwise.py:N]:     val = x[tile]
    # src[test_inline_asm_elementwise.py:N]:     # Shift 4x8bit values together, pack=4
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_packed_asm, (triton.cdiv(512, _BLOCK_SIZE_0),), x, result, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result
    return result

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_shift_operation)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_shift_asm(x, y, result, n, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: val_x = x[tile]
    val_x = tl.load(x + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: val_y = y[tile]
    val_y = tl.load(y + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: shift_val = hl.full(tile, n, dtype=torch.int32)
    shift_val = tl.full([_BLOCK_SIZE_0], n, tl.int32)
    # src[test_inline_asm_elementwise.py:N]: result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     "shf.l.wrap.b32 $0, $1, $2, $3;",
    # src[test_inline_asm_elementwise.py:N]:     "=r,r,r,r",
    # src[test_inline_asm_elementwise.py:N-N]: ...
    result_val = tl.inline_asm_elementwise('shf.l.wrap.b32 $0, $1, $2, $3;', '=r,r,r,r', [val_x, val_y, shift_val], tl.int32, True, 1)
    # src[test_inline_asm_elementwise.py:N]: result[tile] = result_val
    tl.store(result + indices_0 * 1, result_val, None)

def kernel_shift_asm(x: torch.Tensor, y: torch.Tensor, n: int, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result = torch.empty_like(x)
    result = torch.empty_like(x)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    _BLOCK_SIZE_0 = 32
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    # src[test_inline_asm_elementwise.py:N]:     val_x = x[tile]
    # src[test_inline_asm_elementwise.py:N]:     val_y = y[tile]
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_shift_asm, (triton.cdiv(128, _BLOCK_SIZE_0),), x, y, result, n, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result
    return result

--- assertExpectedJournal(TestInlineAsmElementwise.test_inline_asm_simple)
from __future__ import annotations

import torch
import triton
import triton.language as tl
from helion.runtime import default_launcher as _default_launcher

@triton.jit
def _helion_kernel_simple_asm(x, result, _BLOCK_SIZE_0: tl.constexpr):
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    pid_0 = tl.program_id(0)
    offset_0 = pid_0 * _BLOCK_SIZE_0
    indices_0 = (offset_0 + tl.arange(0, _BLOCK_SIZE_0)).to(tl.int32)
    # src[test_inline_asm_elementwise.py:N]: val = x[tile]
    val = tl.load(x + indices_0 * 1, None)
    # src[test_inline_asm_elementwise.py:N]: result_val = hl.inline_asm_elementwise(
    # src[test_inline_asm_elementwise.py:N]:     "mov.u32 $0, $1;",
    # src[test_inline_asm_elementwise.py:N]:     "=r,r",
    # src[test_inline_asm_elementwise.py:N-N]: ...
    result_val = tl.inline_asm_elementwise('mov.u32 $0, $1;', '=r,r', [val], tl.int32, True, 1)
    # src[test_inline_asm_elementwise.py:N]: result[tile] = result_val
    tl.store(result + indices_0 * 1, result_val, None)

def kernel_simple_asm(x: torch.Tensor, *, _launcher=_default_launcher):
    # src[test_inline_asm_elementwise.py:N]: result = torch.empty_like(x)
    result = torch.empty_like(x)
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    _BLOCK_SIZE_0 = 16
    # src[test_inline_asm_elementwise.py:N]: for tile in hl.tile(x.shape):
    # src[test_inline_asm_elementwise.py:N]:     val = x[tile]
    # src[test_inline_asm_elementwise.py:N]:     # Simple mov instruction - copy input to output
    # src[test_inline_asm_elementwise.py:N-N]: ...
    _launcher(_helion_kernel_simple_asm, (triton.cdiv(16, _BLOCK_SIZE_0),), x, result, _BLOCK_SIZE_0, num_warps=4, num_stages=1)
    # src[test_inline_asm_elementwise.py:N]: return result
    return result
